#!/usr/bin/env python3
import math
from math import *
import sys

if (len(sys.argv)==2) and sys.argv[1] == "-h":
    print\
("\
USAGE\n\
    ./104intersection opt xp yp zp xv yv zv p\n\n\
DESCRIPTION\n\
    opt             surface option: 1 for a sphere, 2 for a cylinder, 3 for a cone\n\
    (xp, yp, zp)    coordinates of a point by which the light ray passes through\n\
    (xv, yv, zv)    coordinates of a vector parallel to the light ray\n\
    p               parameter: radius of the sphere, radius of the cylinder, or\n\
                    angle formed by the cone and the Z-axis\
")
    sys.exit(0)
try:
    opt = sys.argv[1]
    opt = int(opt)

    xp = sys.argv[2]
    xp = int(xp)
    yp = sys.argv[3]
    yp = int(yp)
    zp = sys.argv[4]
    zp = int(zp)

    xv = sys.argv[5]
    xv = int(xv)
    yv = sys.argv[6]
    yv = int(yv)
    zv = sys.argv[7]
    zv = int(zv)

    p = sys.argv[8]
    p = int(p)

except:
    print('Invalid input', file=sys.stderr)
    sys.exit(84)

if len(sys.argv) != 9:
    print('Wrong number of arguments', file=sys.stderr)
    sys.exit(84)

if opt not in [1, 2, 3]:
    print('The opt variable must be either 1, 2 or 3', file=sys.stderr)
    sys.exit(84)

if p < 0:
    print('The p variable must be positive', file=sys.stderr)
    sys.exit(84)

def calc_sphere(xp, yp, zp, xv, yv, zv, p):
    print(f"Sphere of radius {p}")
    print(f"Line passing through the point ({xp}, {yp}, {zp}) \
and parrallel to the vector ({xv}, {yv}, {zv})")
    a = (xv**2 + yv**2 + zv**2)
    b = 2*(xp*xv + yp*yv + zp*zv)
    c = (xp**2 + yp**2 + zp**2) - p**2
    if (a == 0):
        if (xp**2 + yp**2 + zp**2 == p**2):
            print(f"1 intersection point:\n\
({xp:<.3f}, {yp:<.3f}, {zp:<.3f})")
            sys.exit(0)
        else:
            print("No intersection point.")
            sys.exit(0)
    delta = b**2 - 4*a*c
    if (delta < 0):
        print("No intersection point.")
        sys.exit(0)
    elif (delta == 0):
        t = -b/(2*a)
        print(f"1 intersection point:\n\
({(xp+t*xv):<.3f}, {(yp+t*yv):<.3f}, {(zp+t*zv):<.3f})")
        sys.exit(0)
    else:
        t1 = (-b + sqrt(delta))/(2*a)
        t2 = (-b - sqrt(delta))/(2*a)
        print(f"2 intersection points:\n\
({(xp+t1*xv):<.3f}, {(yp+t1*yv):<.3f}, {(zp+t1*zv):<.3f})\n\
({(xp+t2*xv):<.3f}, {(yp+t2*yv):<.3f}, {(zp+t2*zv):<.3f})\
")
        sys.exit(0)

def calc_cylinder(xp, yp, zp, xv, yv, zv, p):
    print(f"Cylinder of radius {p}")
    print(f"Line passing through the point ({xp}, {yp}, {zp}) \
and parrallel to the vector ({xv}, {yv}, {zv})")
    if (xp**2 + yp**2 == p**2 and xv == 0 and yv == 0):
        if (zv != 0):
            print("There is an infinite number of intersection points.")
            sys.exit(0)
        if (zv == 0):
            print(f"1 intersection point: ({xp:<.3f}, {yp:<.3f}, {zp:<.3f})")
            sys.exit(0)
    if (xv == 0 and yv == 0):
        print("No intersection point.")
        sys.exit(0)
    a = (xv**2 + yv**2)
    b = 2*(xp*xv + yp*yv)
    c = (xp**2 + yp**2) - p**2
    if (a == 0):    
        if (xp**2 + yp**2 == p**2):
            print(f"1 intersection point:\n\
({xp:<.3f}, {yp:<.3f}, {zp:<.3f})")
            sys.exit(0) 
        else:
            print("No intersection point.")
            sys.sys.exit(0)
    
    delta = b**2 - 4*a*c
    if (delta < 0):
        print("No intersection point.")
        sys.exit(0)
    elif (delta == 0):
        t = -b/(2*a)
        print(f"1 intersection point:\n\
({(xp+t*xv):<.3f}, {(yp+t*yv):<.3f}, {(zp+t*zv):<.3f})")
        sys.exit(0)
    else:
        t1 = (-b + sqrt(delta))/(2*a)
        t2 = (-b - sqrt(delta))/(2*a)
        print(f"2 intersection points:\n\
({(xp+t1*xv):<.3f}, {(yp+t1*yv):<.3f}, {(zp+t1*zv):<.3f})\n\
({(xp+t2*xv):<.3f}, {(yp+t2*yv):<.3f}, {(zp+t2*zv):<.3f})\
")
        sys.exit(0)

def calc_cone(xp, yp, zp, xv, yv, zv, p):
    print(f"Cone with a {p} degree angle")
    print(f"Line passing through the point ({xp}, {yp}, {zp}) \
and parrallel to the vector ({xv}, {yv}, {zv})")
    is_inf = 0
    for i in range (-10000, 10000):
        x = xp + i * xv
        y = yp + i * yv
        z = zp + i * zv
        teta = math.tan(math.radians(p))**2
        if (x**2 + y**2 == teta * (z**2)):
            is_inf += 1
    teta = math.tan(math.radians(p))**2
    if (is_inf == 3):
        print("There is an infinite number of intersection points.")
        sys.exit(0)
    a = (xv**2 + yv**2)-(teta*(zv**2))
    b = 2*(xp*xv + yp*yv)-(teta*zp*zv)
    c = (xp**2 + yp**2) - (teta*(zp**2))
    if (a == 0):
        if (xp**2 + yp**2 == p**2):
            print(f"1 intersection point:\n\
({xp:<.3f}, {yp:<.3f}, {zp:<.3f})")
            sys.exit(0)
        else:
            print("No intersection point.")
            sys.exit(0)
    
    delta = b**2 - 4*a*c
    if (delta < 0):
        print("No intersection point.")
        sys.exit(0)
    elif (delta == 0):
        t = -b/(2*a)
        print(f"1 intersection point:\n\
({(xp+t*xv):<.3f}, {(yp+t*yv):<.3f}, {(zp+t*zv):<.3f})")
        sys.exit(0)
    else:
        t1 = (-b + sqrt(delta))/(2*a)
        t2 = (-b - sqrt(delta))/(2*a)
        print(f"2 intersection points:\n\
({(xp+t1*xv):<.3f}, {(yp+t1*yv):<.3f}, {(zp+t1*zv):<.3f})\n\
({(xp+t2*xv):<.3f}, {(yp+t2*yv):<.3f}, {(zp+t2*zv):<.3f})\
")
        sys.exit(0)

if (opt == 1):
    calc_sphere(xp, yp, zp, xv, yv, zv, p)

if (opt == 2):
    calc_cylinder(xp, yp, zp, xv, yv, zv, p)

try:
    if (opt == 3):
        calc_cone(xp, yp, zp, xv, yv, zv, p)
except:
    pass